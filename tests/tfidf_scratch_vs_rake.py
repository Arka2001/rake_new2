# Hacky fix to remove top-level import errors
import sys
from timeit import default_timer as timer

from rake_new2 import Rake
from tfidf_vectorizer.extract_keywords_tfidf_scratch import TF_IDF_Scratch

sys.path.append("..")

docs = [
    "Java is a class based, object oriented programming language that is designed to have as few implementation dependencies as possible. It is a general purpose programming language intended to let application developers write once, run anywhere, meaning that compiled Java code can run on all platforms that support Java without the need for recompilation.",
    "C++ is a general purpose programming language created by Bjarne Stroustrup as an extension of the C programming language, or 'C with Classes'. The language has expanded significantly over time, and modern C++ now has object oriented, generic, and functional features in addition to facilities for low-level memory manipulation.",
    "Python is an interpreted, high level and general purpose programming language. Created by Guido van Rossum and first released in 1991, Python's design philosophy emphasizes code readability with its notable use of significant whitespace. Its language constructs and object oriented approach aim to help programmers write clear, logical code for small and large scale projects.",
    "Haskell is a general purpose, statically typed, purely functional programming language with type inference and lazy evaluation. Developed to be suitable for teaching, research and industrial application, Haskell has pioneered a number of advanced programming language features such as type classes, which enable type safe operator overloading.",
    "Kotlin is a cross platform, statically typed, general purpose programming language with type inference. Kotlin is designed to interoperate fully with Java, and the JVM version of Kotlin's standard library depends on the Java Class Library, but type inference allows its syntax to be more concise. Kotlin mainly targets the JVM, but also compiles to JavaScript or native code (via LLVM), e.g. for native iOS apps sharing business logic with Android apps. Language development costs are borne by JetBrains, while the Kotlin Foundation protects the Kotlin trademark.",
]

manual_keyphrases = [
    "python",
    "guido van rossum",
    "first released",
    "1991",
    "notable",
    "interpreted",
    "high level",
    "general purpose",
    "design philosophy",
    "code readability",
    "whitespace",
    "language constructs",
    "object oriented",
    "clear",
    "logical",
    "small",
    "large scale projects",
]

test_doc_idx = 2

start_tfidf = timer()
# creating the tfidf runner object
tfidf = TF_IDF_Scratch()
# running tfidf on the test document, with the full set of docs as the corpus
# getting a list of word-score pairs sorted in descending order of tfidf scores
# then removing the scores to only keep the words and building a set for fast O(1) access
tfidf_res = set([word[0] for word in tfidf.get_keywords(docs, test_doc_idx)])
end_tfidf = timer()

start_rake = timer()
# creating the rake runner object
rake = Rake()
# running rake on the test document (no corpus)
rake.get_keywords_from_raw_text(docs[test_doc_idx])
# getting a set of ranked keywords as a result of running rake
rake_res = rake.get_ranked_keywords()
end_rake = timer()

# printing the results recieved from running tfidf and rake
# on the same test document
print("tf-idf (scratch) results: ")
print(tfidf_res)
print()
print("rake results: ")
print(rake_res)
print()

# tfidf_total and rake_total are the counts of the number of words returned
# by tfidf and rake respectively
# tfidf_total = tfidf true positives + tfidf false positives
# rake_total  = rake true positives  + rake false positives
tfidf_total = len(tfidf_res)
tfidf_tp = 0
rake_total = len(rake_res)
rake_tp = 0
for keyphrase in manual_keyphrases:
    # if manually generated keyphrase is present in the result,
    # it is a true positive for that algorithm
    # this code counts the true positives generated by tfidf and rake
    if keyphrase in tfidf_res:
        tfidf_tp += 1
    if keyphrase in rake_res:
        rake_tp += 1

# the precision score is calculated as true positives / true positives + false positives
# or, precision score = true positives / total
# then, the precision score is converted into a percentage, denoting the relativity
# of true positives with all generated keywords
# this gives us an insight into how accurate each algorithm is
tfidf_precision = tfidf_tp / tfidf_total * 100
rake_precision = rake_tp / rake_total * 100

# formatting the scores and times to be human readable by rounding to two decimal places
print("tf-idf (scratch) precision score: " + str(round(tfidf_precision, 2)) +
      "%")
print("rake precision score: " + str(round(rake_precision, 2)) + "%")
print()

print("tf-idf (scratch) time: " + str(round(end_tfidf - start_tfidf, 3)) + "s")
print("rake time: " + str(round(end_rake - start_rake, 3)) + "s")
